{
	"!name": "threejs",
	"Camera": {
		"!url": "http://threejs.org/docs/#api/cameras/Camera",
		"prototype": {
			"!proto": "Object3D.prototype",
			"matrixWorldInverse": {
				"!type": "+Matrix4",
				"!doc": "This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera."
			},
			"projectionMatrix": {
				"!type": "+Matrix4",
				"!doc": "This is the matrix which contains the projection."
			},
			"lookAt": {
				"!type": "fn(vector: +Vector3)",
				"!doc": "vector â€” point to look at<br>\n\t\t<br>\n\t\tThis makes the camera look at the vector position in the global space as long as the parent of this camera is the scene or at position (0,0,0)."
			}
		},
		"!doc": "Abstract base class for cameras. This class should always be inherited when you build a new camera.",
		"!type": "fn()"
	},
	"CubeCamera": {
		"!url": "http://threejs.org/docs/#api/cameras/CubeCamera",
		"prototype": {
			"!proto": "Object3D.prototype",
			"renderTarget": {
				"!type": "+WebGLRenderTargetCube",
				"!doc": "The cube texture that gets generated."
			},
			"updateCubeMap": {
				"!type": "fn(renderer: todo, scene: todo) -> todo",
				"!doc": "Call this to update the renderTarget."
			}
		},
		"!doc": "Creates 6 cameras that render to a [page:WebGLRenderTargetCube].",
		"!type": "fn(near: number, far: number, cubeResolution: number)"
	},
	"OrthographicCamera": {
		"!url": "http://threejs.org/docs/#api/cameras/OrthographicCamera",
		"prototype": {
			"!proto": "Camera.prototype",
			"left": {
				"!type": "number",
				"!doc": "Camera frustum left plane."
			},
			"right": {
				"!type": "number",
				"!doc": "Camera frustum right plane."
			},
			"top": {
				"!type": "number",
				"!doc": "Camera frustum top plane."
			},
			"bottom": {
				"!type": "number",
				"!doc": "Camera frustum bottom plane."
			},
			"near": {
				"!type": "number",
				"!doc": "Camera frustum near plane."
			},
			"far": {
				"!type": "number",
				"!doc": "Camera frustum far plane."
			},
			"updateProjectionMatrix": {
				"!type": "fn()",
				"!doc": "Updates the camera projection matrix. Must be called after change of parameters."
			}
		},
		"!doc": "Camera with orthographic projection.",
		"!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number)"
	},
	"PerspectiveCamera": {
		"!url": "http://threejs.org/docs/#api/cameras/PerspectiveCamera",
		"prototype": {
			"!proto": "Camera.prototype",
			"fov": {
				"!type": "number",
				"!doc": "Camera frustum vertical field of view, from bottom to top of view, in degrees."
			},
			"aspect": {
				"!type": "number",
				"!doc": "Camera frustum aspect ratio, window width divided by window height."
			},
			"near": {
				"!type": "number",
				"!doc": "Camera frustum near plane."
			},
			"far": {
				"!type": "number",
				"!doc": "Camera frustum far plane."
			},
			"setLens": {
				"!type": "fn(focalLength: number, frameSize: number)",
				"!doc": "Uses focal length (in mm) to estimate and set FOV 35mm (fullframe) camera is used if frame size is not specified.<br>\n\t\tFormula based on [link:http://www.bobatkins.com/photography/technical/field_of_view.html]"
			},
			"setViewOffset": {
				"!type": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
				"!doc": "For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:<br>\n\n\t\t<pre>+---+---+---+\n| A | B | C |\n+---+---+---+\n| D | E | F |\n+---+---+---+</pre>\n\n\t\tthen for each monitor you would call it like this:<br>\n\n\t\t<code>var w = 1920;\nvar h = 1080;\nvar fullWidth = w * 3;\nvar fullHeight = h * 2;\n\n// A\ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n// B\ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n// C\ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n// D\ncamera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n// E\ncamera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n// F\ncamera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n</code>\n\n\t\tNote there is no reason monitors have to be the same size or in a grid."
			},
			"updateProjectionMatrix": {
				"!type": "fn()",
				"!doc": "Updates the camera projection matrix. Must be called after change of parameters."
			}
		},
		"!doc": "Camera with perspective projection.",
		"!type": "fn(fov: number, aspect: number, near: number, far: number)"
	},
	"CustomBlendingEquations": {
		"!url": "http://threejs.org/docs/#api/constants/CustomBlendingEquations",
		"prototype": {}
	},
	"GLState": {
		"!url": "http://threejs.org/docs/#api/constants/GLState",
		"prototype": {}
	},
	"Materials": {
		"!url": "http://threejs.org/docs/#api/constants/Materials",
		"prototype": {}
	},
	"ShadowingTypes": {
		"!url": "http://threejs.org/docs/#api/constants/ShadowingTypes",
		"prototype": {}
	},
	"Textures": {
		"!url": "http://threejs.org/docs/#api/constants/Textures",
		"prototype": {}
	},
	"BufferAttribute": {
		"!url": "http://threejs.org/docs/#api/core/BufferAttribute",
		"prototype": {
			"array": {
				"!type": "[]",
				"!doc": "Stores the data associated with this attribute; can be an Array or a Typed Array. This element should have <code>itemSize * numVertices</code> elements, where numVertices is the number of vertices in the associated [page:BufferGeometry geometry]."
			},
			"itemSize": {
				"!type": "number",
				"!doc": "Records how many items of the array are associated with a particular vertex. For instance, if this\n\t\tattribute is storing a 3-component vector (such as a position, normal, or color), then itemSize should be 3."
			},
			"length": {
				"!type": "number",
				"!doc": "Gives the total number of elements in the array."
			},
			"needsUpdate": {
				"!type": "bool",
				"!doc": "Flag to indicate that this attribute has changed and should be re-send to the GPU. Set this to true when you modify the value of the array."
			},
			"setX": {
				"!type": "fn(index, x)",
				"!doc": "Sets the value of the array at <code>index * itemSize</code> to x"
			},
			"setY": {
				"!type": "fn(index, y)",
				"!doc": "Sets the value of the array at <code>index * itemSize + 1</code> to y"
			},
			"setZ": {
				"!type": "fn(index, z)",
				"!doc": "Sets the value of the array at <code>index * itemSize + 2</code> to z"
			},
			"setXY": {
				"!type": "fn(index, x, y)",
				"!doc": "Sets the value of the array at <code>index * itemSize</code> to x and \n\t\tsets the value of the array at <code>index * itemSize + 1</code> to y"
			},
			"setXYZ": {
				"!type": "fn(index, x, y, z)",
				"!doc": "Sets the value of the array at <code>index * itemSize</code> to x,\n\t\tthe value of the array at <code>index * itemSize + 1</code> to y, and\n\t\tthe value of the array at <code>index * itemSize + 2</code> to z."
			},
			"setXYZW": {
				"!type": "fn(index, x, y, z, w)",
				"!doc": "Sets the value of the array at <code>index * itemSize</code> to x,\n\t\tthe value of the array at <code>index * itemSize + 1</code> to y, \n\t\tthe value of the array at <code>index * itemSize + 2</code> to z, and\n\t\tthe value of the array at <code>index * itemSize + 3</code> to w."
			},
			"clone": {
				"!type": "fn() -> +BufferAttribute",
				"!doc": "Copies this attribute."
			}
		},
		"!doc": "This class stores data for an attribute associated with a [page:BufferGeometry]. See that page for details and a usage example. This class is used to store builtin attributes such as vertex position, normals, color, etc., but can also be used in your code to store custom attributes in a [page:BufferGeometry].",
		"!type": "fn(array: [], itemSize: number)"
	},
	"BufferGeometry": {
		"!url": "http://threejs.org/docs/#api/core/BufferGeometry",
		"prototype": {
			"id": {
				"!type": "number",
				"!doc": "Unique number for this buffergeometry instance."
			},
			"attributes": {
				"!type": "Hashmap",
				"!doc": "This hashmap has as id the name of the attribute to be set and as value the [page:BufferAttribute buffer] to set it to.\n\t\tRather than accessing this property directly, use addAttribute and getAttribute to access attributes of this geometry."
			},
			"drawCalls": {
				"!type": "[]",
				"!doc": "For geometries that use indexed triangles, this Array can be used to split the object into multiple WebGL draw calls. Each draw call will draw some subset of the vertices in this geometry using the configured [page:Material shader]. This may be necessary if, for instance, you have more than 65535 vertices in your object. \n\t\tEach element is an object of the form:\n\t\t<code>{ start: Integer, count: Integer, index: Integer }</code>\n\t\twhere start specifies the index of the first vertex in this draw call, count specifies how many vertices are included, and index specifies an optional offset.\n\n\t\tUse addDrawCall to add draw calls, rather than modifying this array directly."
			},
			"boundingBox": {
				"!type": "+Box3",
				"!doc": "Bounding box.\n\t\t<code>{ min: new Vector3(), max: new Vector3() }</code>"
			},
			"boundingSphere": {
				"!type": "+Sphere",
				"!doc": "Bounding sphere.\n\t\t<code>{ radius: float }</code>"
			},
			"morphTargets": {
				"!type": "[]",
				"!doc": "Array of morph targets. Each morph target is a Javascript object:\n\t\t<code>{ name: \"targetName\", vertices: [ new Vertex(), ... ] }</code>\n\t\tMorph vertices match number and order of primary vertices."
			},
			"addAttribute": {
				"!type": "null",
				"!doc": "Adds an attribute to this geometry. Use this rather than the attributes property, \n\t\tbecause an internal array of attributes is maintained to speed up iterating over\n\t\tattributes."
			},
			"addDrawCall": {
				"!type": "fn(start: number, count: number, indexOffset: number)",
				"!doc": "Adds a draw call to this geometry; see the drawcalls property for details."
			},
			"applyMatrix": {
				"!type": "fn(matrix: +Matrix4)",
				"!doc": "Bakes matrix transform directly into vertex coordinates."
			},
			"computeVertexNormals": {
				"!type": "fn()",
				"!doc": "Computes vertex normals by averaging face normals.<br>"
			},
			"computeBoundingBox": {
				"!type": "fn()",
				"!doc": "Computes bounding box of the geometry, updating [page:Geometry Geometry.boundingBox] attribute.<br>\n\t\tBounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are *null*."
			},
			"computeBoundingSphere": {
				"!type": "fn()",
				"!doc": "Computes bounding sphere of the geometry, updating [page:Geometry Geometry.boundingSphere] attribute.<br>\n\t\tBounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are *null*."
			},
			"dispose": {
				"!type": "fn()",
				"!doc": "Disposes the object from memory. <br>\n\t\tYou need to call this when you want the bufferGeometry removed while the application is running."
			},
			"fromGeometry": {
				"!type": "fn()",
				"!doc": "Populates this BufferGeometry with data from a [page:Geometry] object."
			},
			"getAttribute": {
				"!type": "fn(name: string) -> +BufferAttribute",
				"!doc": "Returns the [page:BufferAttribute attribute] with the specified name."
			},
			"normalizeNormals": {
				"!type": "fn()",
				"!doc": "Every normal vector in a geometry will have a magnitude of 1.\n\t\tThis will correct lighting on the geometry surfaces."
			}
		},
		"!doc": "<p>\n\t\tThis class is an efficient alternative to [page:Geometry], because it stores all data, including\n\t\tvertex positions, face indices, normals, colors, UVs, and custom attributes within buffers; this\n\t\treduces the cost of passing all this data to the GPU. \n\t\tThis also makes BufferGeometry harder to work with than [page:Geometry]; rather than accessing \n\t\tposition data as [page:Vector3] objects, color data as [page:Color] objects, and so on, you have to \n\t\taccess the raw data from the appropriate [page:BufferAttribute attribute] buffer. This makes \n\t\tBufferGeometry best-suited for static objects where you don't need to manipulate the geometry much\n\t\tafter instantiating it.\n\t\t</p>\n\n\t\t<h3>Example</h3>\n\t\t<code>\n\t\tvar geometry = new BufferGeometry();\n\t\t// create a simple square shape. We duplicate the top left and bottom right\n\t\t// vertices because each vertex needs to appear once per triangle. \n\t\tvar vertexPositions = [ \n\t\t\t[-1.0, -1.0,  1.0],\n\t\t\t[ 1.0, -1.0,  1.0],\n\t\t\t[ 1.0,  1.0,  1.0],\n\n\t\t\t[ 1.0,  1.0,  1.0],\n\t\t\t[-1.0,  1.0,  1.0],\n\t\t\t[-1.0, -1.0,  1.0]\n\t\t];\n\t\tvar vertices = new Float32Array( vertexPositions.length * 3 ); // three components per vertex\n\n\t\t// components of the position vector for each vertex are stored\n\t\t// contiguously in the buffer.\n\t\tfor ( var i = 0; i &lt; vertexPositions.length; i++ )\n\t\t{\n\t\t\tvertices[ i*3 + 0 ] = vertexPositions[i][0];\n\t\t\tvertices[ i*3 + 1 ] = vertexPositions[i][1];\n\t\t\tvertices[ i*3 + 2 ] = vertexPositions[i][2];\n\t\t}\n\n\t\t// itemSize = 3 because there are 3 values (components) per vertex\n\t\tgeometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\tvar material = new MeshBasicMaterial( { color: 0xff0000 } );\n\t\tvar mesh = new Mesh( geometry, material );\n\t\t</code>\n\t\t<p>More examples: [example:webgl_buffergeometry Complex mesh with non-indexed faces], [example:webgl_buffergeometry_uint Complex mesh with indexed faces], [example:webgl_buffergeometry_lines Lines], [example:webgl_buffergeometry_lines_indexed Indexed Lines], [example:webgl_buffergeometry_particles Particles], and [example:webgl_buffergeometry_rawshader Raw Shaders].</p>\n\n\t\t\n\t\t<h3>Accessing attributes</h3>\n\t\t<p>\n\t\tWebGL stores data associated with individual vertices of a geometry in <emph>attributes</emph>. \n\t\tExamples include the position of the vertex, the normal vector for the vertex, the vertex color,\n\t\tand so on. When using [page:Geometry], the [page:WebGLRenderer renderer] takes care of wrapping\n\t\tup this information into typed array buffers and sending this data to the shader. With \n\t\tBufferGeometry, all of this data is stored in buffers associated with an individual attributes.\n\t\tThis means that to get the position data associated with a vertex (for instance), you must call\n\t\t[page:.getAttribute] to access the 'position' [page:BufferAttribute attribute], then access the individual \n\t\tx, y, and z coordinates of the position.  \n\t\t</p>\n\t\t<p>\n\t\tThe following attributes are set by various members of this class:\n\t\t</p>\n\t\t<h4>[page:BufferAttribute position] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z coordinates of each vertex in this geometry. Set by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute normal] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z components of the face or vertex normal vector of each vertex in this geometry.\n\t\tSet by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute color] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the red, green, and blue channels of vertex color of each vertex in this geometry.\n\t\tSet by [page:.fromGeometry]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute tangent] (itemSize: 3)</h4>\n\t\t<div>\n\t\tStores the x, y, and z components of the tangent vector of each vertex in this geometry. Set by [page:.computeTangents]().\n\t\t</div>\n\n\t\t<h4>[page:BufferAttribute index] (itemSize: 3)</h4>\n\t\tAllows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles,\" and works much the same as it does in [page:Geometry]: each triangle is associated with the index of three vertices. This attribute therefore stores the index of each vertex for each triangular face.\n\n\t\tIf this attribute is not set, the [page:WebGLRenderer renderer] assumes that each three contiguous positions represent a single triangle.",
		"!type": "fn()"
	},
	"Clock": {
		"!url": "http://threejs.org/docs/#api/core/Clock",
		"prototype": {
			"autoStart": {
				"!type": "bool",
				"!doc": "If set, starts the clock automatically when the first update is called."
			},
			"startTime": {
				"!type": "number",
				"!doc": "When the clock is running, It holds the start time of the clock. <br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
			},
			"oldTime": {
				"!type": "number",
				"!doc": "When the clock is running, It holds the previous time from a update.<br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
			},
			"elapsedTime": {
				"!type": "number",
				"!doc": "When the clock is running, It holds the time elapsed between the start of the clock to the previous update.<br>\n\t\tThis counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
			},
			"running": {
				"!type": "bool",
				"!doc": "This property keeps track whether the clock is running or not."
			},
			"start": {
				"!type": "fn()",
				"!doc": "Starts clock."
			},
			"stop": {
				"!type": "fn()",
				"!doc": "Stops clock."
			},
			"getElapsedTime": {
				"!type": "fn() -> number",
				"!doc": "Get the seconds passed since the clock started."
			},
			"getDelta": {
				"!type": "fn() -> number",
				"!doc": "Get the seconds passed since the last call to this method."
			}
		},
		"!doc": "Object for keeping track of time.",
		"!type": "fn(autoStart: bool)"
	},
	"EventDispatcher": {
		"!url": "http://threejs.org/docs/#api/core/EventDispatcher",
		"prototype": {
			"addEventListener": {
				"!type": "fn(type: string, listener: function)",
				"!doc": "Adds a listener to an event type."
			},
			"hasEventListener": {
				"!type": "fn(type: string, listener: function) -> bool",
				"!doc": "Checks if listener is added to an event type."
			},
			"removeEventListener": {
				"!type": "fn(type: string, listener: function)",
				"!doc": "Removes a listener from an event type."
			},
			"dispatchEvent": {
				"!type": "fn(type: string)",
				"!doc": "Fire an event type."
			}
		},
		"!doc": "JavaScript events for custom objects.<br>\n\t\t<a href=\"https://github.com/mrdoob/eventdispatcher.js\">https://github.com/mrdoob/eventdispatcher.js</a>",
		"!type": "fn()"
	},
	"Face3": {
		"!url": "http://threejs.org/docs/#api/core/Face3",
		"prototype": {
			"a": {
				"!type": "number",
				"!doc": "Vertex A index."
			},
			"b": {
				"!type": "number",
				"!doc": "Vertex B index."
			},
			"c": {
				"!type": "number",
				"!doc": "Vertex C index."
			},
			"normal": {
				"!type": "+Vector3",
				"!doc": "Face normal."
			},
			"color": {
				"!type": "+Color",
				"!doc": "Face color."
			},
			"vertexNormals": {
				"!type": "[]",
				"!doc": "Array of 3 vertex normals."
			},
			"vertexColors": {
				"!type": "[]",
				"!doc": "Array of 3 vertex colors."
			},
			"materialIndex": {
				"!type": "number",
				"!doc": "Material index (points to [page:MultiMaterial MultiMaterial.materials])."
			},
			"clone": {
				"!type": "fn() -> +Face3",
				"!doc": "Creates a new clone of the Face3 object."
			}
		},
		"!doc": "Triangle face.",
		"!type": "fn(a: number, b: number, c: number, normal: +Vector3, color: +Color, materialIndex: number)"
	},
	"Geometry": {
		"!url": "http://threejs.org/docs/#api/core/Geometry",
		"prototype": {
			"id": {
				"!type": "number",
				"!doc": "Unique number for this geometry instance."
			},
			"name": {
				"!type": "string",
				"!doc": "Name for this geometry. Default is an empty string."
			},
			"vertices": {
				"!type": "[]",
				"!doc": "Array of [page:Vector3 vertices].<br>\n\t\tThe array of vertices holds every position of points in the model.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.verticesNeedUpdate] needs to be set to true."
			},
			"colors": {
				"!type": "[]",
				"!doc": "Array of vertex [page:Color colors], matching number and order of vertices.<br>\n\t\tUsed in [page:PointCloud] and [page:Line].<br>\n\t\t[page:Mesh Meshes] use per-face-use-of-vertex colors embedded directly in faces.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.colorsNeedUpdate] needs to be set to true."
			},
			"faces": {
				"!type": "[]",
				"!doc": "Array of [page:Face3 triangles].<br>\n\t\tThe array of faces describe how each vertex in the model is connected with each other.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.elementsNeedUpdate] needs to be set to true."
			},
			"faceVertexUvs": {
				"!type": "[]",
				"!doc": "Array of face [page:UV] layers.<br>\n\t\tEach UV layer is an array of [page:UV]s matching the order and number of vertices in faces.<br>\n\t\tTo signal an update in this array, [page:Geometry Geometry.uvsNeedUpdate] needs to be set to true."
			},
			"morphTargets": {
				"!type": "[]",
				"!doc": "Array of morph targets. Each morph target is a Javascript object:\n\t\t<code>{ name: \"targetName\", vertices: [ new Vector3(), ... ] }</code>\n\t\tMorph vertices match number and order of primary vertices."
			},
			"morphNormals": {
				"!type": "[]",
				"!doc": "Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:\n\t\t<code>morphNormal = { name: \"NormalName\", normals: [ new Vector3(), ... ] }</code>"
			},
			"skinWeights": {
				"!type": "[]",
				"!doc": "Array of skinning weights, matching number and order of vertices."
			},
			"skinIndices": {
				"!type": "[]",
				"!doc": "Array of skinning indices, matching number and order of vertices."
			},
			"boundingBox": {
				"!type": "object",
				"!doc": "Bounding box.\n\t\t<code>{ min: new Vector3(), max: new Vector3() }</code>"
			},
			"boundingSphere": {
				"!type": "object",
				"!doc": "Bounding sphere.\n\t\t<code>{ radius: float }</code>"
			},
			"dynamic": {
				"!type": "bool",
				"!doc": "Set to *true* if attribute buffers will need to change in runtime (using \"dirty\" flags).<br>\n\t\tUnless set to true internal typed arrays corresponding to buffers will be deleted once sent to GPU.<br>\n\t\tDefaults to true."
			},
			"verticesNeedUpdate": {
				"!type": "bool",
				"!doc": "Set to *true* if the vertices array has been updated."
			},
			"elementsNeedUpdate": {
				"!type": "bool",
				"!doc": "Set to *true* if the faces array has been updated."
			},
			"uvsNeedUpdate": {
				"!type": "bool",
				"!doc": "Set to *true* if the uvs array has been updated."
			},
			"normalsNeedUpdate": {
				"!type": "bool",
				"!doc": "Set to *true* if the normals array has been updated."
			},
			"colorsNeedUpdate": {
				"!type": "bool",
				"!doc": "Set to *true* if the colors array has been updated."
			},
			"lineDistancesNeedUpdate": {
				"!type": "bool",
				"!doc": "Set to *true* if the linedistances array has been updated."
			},
			"lineDistances": {
				"!type": "array",
				"!doc": "An array containing distances between vertices for Line geometries.\n\t\tThis is required for LinePieces/LineDashedMaterial to render correctly.\n\t\tLine distances can also be generated with computeLineDistances."
			},
			"applyMatrix": {
				"!type": "fn(matrix: +Matrix4)",
				"!doc": "Bakes matrix transform directly into vertex coordinates."
			},
			"computeFaceNormals": {
				"!type": "fn()",
				"!doc": "Computes face normals."
			},
			"computeVertexNormals": {
				"!type": "fn()",
				"!doc": "Computes vertex normals by averaging face normals.<br>\n\t\tFace normals must be existing / computed beforehand."
			},
			"computeMorphNormals": {
				"!type": "fn()",
				"!doc": "Computes morph normals."
			},
			"computeBoundingBox": {
				"!type": "fn()",
				"!doc": "Computes bounding box of the geometry, updating [page:Geometry Geometry.boundingBox] attribute."
			},
			"computeBoundingSphere": {
				"!type": "fn()",
				"!doc": "Neither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are *null*."
			},
			"merge": {
				"!type": "fn(geometry: +Geometry, matrix: +Matrix4, materialIndexOffset: number)",
				"!doc": "Merge two geometries or geometry and geometry from object (using object's transform)"
			},
			"mergeVertices": {
				"!type": "fn()",
				"!doc": "Checks for duplicate vertices using hashmap.<br>\n\t\tDuplicated vertices are removed and faces' vertices are updated."
			},
			"clone": {
				"!type": "fn() -> +Geometry",
				"!doc": "Creates a new clone of the Geometry."
			},
			"dispose": {
				"!type": "fn()",
				"!doc": "Removes The object from memory. <br>\n\t\tDon't forget to call this method when you remove a geometry because it can cause memory leaks."
			},
			"computeLineDistances": {
				"!type": "fn()",
				"!doc": "Compute distances between vertices for Line geometries."
			}
		},
		"!doc": "Base class for geometries.<br>\n\t\tA geometry holds all data necessary to describe a 3D model.",
		"!type": "fn()"
	},
	"Object3D": {
		"!url": "http://threejs.org/docs/#api/core/Object3D",
		"prototype": {
			"id": {
				"!type": "number",
				"!doc": "readonly â€“ Unique number for this object instance."
			},
			"uuid": {
				"!type": "string",
				"!doc": "[link:http://en.wikipedia.org/wiki/Universally_unique_identifier UUID] of this object instance.\n\t\tThis gets automatically assigned, so this shouldn't be edited."
			},
			"name": {
				"!type": "string",
				"!doc": "Optional name of the object (doesn't need to be unique)."
			},
			"parent": {
				"!type": "+Object3D",
				"!doc": "Object's parent in the scene graph."
			},
			"children": {
				"!type": "+Object3D",
				"!doc": "Array with object's children."
			},
			"position": {
				"!type": "+Vector3",
				"!doc": "Object's local position."
			},
			"rotation": {
				"!type": "+Euler",
				"!doc": "Object's local rotation (<a href=\"https://en.wikipedia.org/wiki/Euler_angles\" target=\"_blank\">Euler angles</a>), in radians."
			},
			"scale": {
				"!type": "+Vector3",
				"!doc": "Object's local scale."
			},
			"up": {
				"!type": "+Vector3",
				"!doc": "Up direction."
			},
			"matrix": {
				"!type": "+Matrix4",
				"!doc": "Local transform."
			},
			"quaternion": {
				"!type": "+Quaternion",
				"!doc": "Object's local rotation as [page:Quaternion Quaternion]."
			},
			"visible": {
				"!type": "bool",
				"!doc": "default â€“ true"
			},
			"castShadow": {
				"!type": "bool",
				"!doc": "default â€“ false"
			},
			"receiveShadow": {
				"!type": "bool",
				"!doc": "default â€“ false"
			},
			"frustumCulled": {
				"!type": "bool",
				"!doc": "default â€“ true"
			},
			"matrixAutoUpdate": {
				"!type": "bool",
				"!doc": "default â€“ true"
			},
			"matrixWorldNeedsUpdate": {
				"!type": "bool",
				"!doc": "default â€“ false"
			},
			"userData": {
				"!type": "object",
				"!doc": "An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned."
			},
			"matrixWorld": {
				"!type": "+Matrix4",
				"!doc": "The global transform of the object. If the Object3d has no parent, then it's identical to the local transform."
			},
			"applyMatrix": {
				"!type": "fn(matrix: +Matrix4)",
				"!doc": "This updates the position, rotation and scale with the matrix."
			},
			"translateX": {
				"!type": "fn(distance: number)",
				"!doc": "Translates object along x axis by distance."
			},
			"translateY": {
				"!type": "fn(distance: number)",
				"!doc": "Translates object along y axis by distance."
			},
			"translateZ": {
				"!type": "fn(distance: number)",
				"!doc": "Translates object along z axis by distance."
			},
			"localToWorld": {
				"!type": "fn(vector: +Vector3) -> +Vector3",
				"!doc": "Updates the vector from local space to world space."
			},
			"worldToLocal": {
				"!type": "fn(vector: +Vector3) -> +Vector3",
				"!doc": "Updates the vector from world space to local space."
			},
			"lookAt": {
				"!type": "fn(vector: +Vector3)",
				"!doc": "Rotates object to face point in space."
			},
			"traverse": {
				"!type": "fn(callback: function)",
				"!doc": "Executes the callback on this object and all descendants."
			},
			"traverseVisible": {
				"!type": "fn(callback: function)",
				"!doc": "Like traverse, but the callback will only be executed for visible objects.\n\t\tDescendants of invisible objects are not traversed."
			},
			"traverseAncestors": {
				"!type": "fn(callback: function)",
				"!doc": "Executes the callback on this object and all ancestors."
			},
			"updateMatrix": {
				"!type": "fn()",
				"!doc": "Updates local transform."
			},
			"updateMatrixWorld": {
				"!type": "fn(force: bool)",
				"!doc": "Updates global transform of the object and its children."
			},
			"clone": {
				"!type": "fn() -> +Object3D",
				"!doc": "Creates a new clone of this object and all descendants."
			},
			"getObjectByName": {
				"!type": "fn(name: string) -> +Object3D",
				"!doc": "Searches through the object's children and returns the first with a matching name."
			},
			"getObjectById": {
				"!type": "fn(id: number) -> +Object3D",
				"!doc": "Searches through the object's children and returns the first with a matching id."
			},
			"translateOnAxis": {
				"!type": "fn(axis: +Vector3, distance: number) -> +Object3D",
				"!doc": "Translate an object by distance along an axis in object space. The axis is assumed to be normalized."
			},
			"rotateOnAxis": {
				"!type": "fn(axis: +Vector3, angle: number) -> +Object3D",
				"!doc": "Rotate an object along an axis in object space. The axis is assumed to be normalized."
			},
			"raycast": {
				"!type": "fn(raycaster: +Raycaster, intersects: []) -> []",
				"!doc": "Abstract method to get intersections between a casted ray and this object. Subclasses such as [page:Mesh], [page:Line], and [page:PointCloud] implement this method in order to participate in raycasting."
			}
		},
		"!doc": "Base class for scene graph objects.",
		"!type": "fn()"
	},
	"Raycaster": {
		"!url": "http://threejs.org/docs/#api/core/Raycaster",
		"prototype": {
			"ray": {
				"!type": "+Ray",
				"!doc": "The Ray used for the raycasting."
			},
			"near": {
				"!type": "float",
				"!doc": "The near factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br>\n\t\tThis value shouldn't be negative and should be smaller than the far property."
			},
			"far": {
				"!type": "float",
				"!doc": "The far factor of the raycaster. This value indicates which objects can be discarded based on the distance.<br>\n\t\tThis value shouldn't be negative and should be larger than the near property."
			},
			"precision": {
				"!type": "float",
				"!doc": "The precision factor of the raycaster when intersecting [page:Mesh] objects."
			},
			"set": {
				"!type": "fn(origin: +Vector3, direction: +Vector3)",
				"!doc": "Updates the ray with a new origin and direction."
			},
			"setFromCamera": {
				"!type": "fn(coords: +Vector2, camera: +Camera)",
				"!doc": "Updates the ray with a new origin and direction."
			},
			"intersectObject": {
				"!type": "fn(object: +Object3D, recursive: bool) -> []",
				"!doc": "Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first. An array of intersections is returned...\n        <code>\n            [ { distance, point, face, faceIndex, indices, object }, ... ]\n        </code>\n        <p>\n        [page:Float distance] â€“ distance between the origin of the ray and the intersection<br>\n        [page:Vector3 point] â€“ point of intersection, in world coordinates<br>\n        [page:Face3 face] â€“ intersected face<br>\n        [page:Integer faceIndex] â€“ index of the intersected face<br>\n        [page:Array indices] â€“ indices of vertices comprising the intersected face<br>\n        [page:Object3D object] â€“ the intersected object\n    \t</p>\n        <p>\n        When intersecting a [page:Mesh] with a [page:BufferGeometry], the *faceIndex* will be *undefined*, and *indices* will be set; when intersecting a [page:Mesh] with a [page:Geometry], *indices* will be *undefined*. \n        </p>\n\t\t<p>\n\t\t*Raycaster* delegates to the [page:Object3D.raycast raycast] method of the passed object, when evaluating whether the ray intersects the object or not. This allows [page:Mesh meshes] to respond differently to ray casting than [page:Line lines] and [page:PointCloud pointclouds].\n\t\t</p>\n\t\t<p>\n\t\t*Note* that for meshes, faces must be pointed towards the origin of the [page:.ray ray] in order to be detected; intersections of the ray passing through the back of a face will not be detected. To raycast against both faces of an object, you'll want to set the [page:Mesh.material material]'s [page:Material.side side] property to *DoubleSide*.  \n\t\t</p>"
			},
			"intersectObjects": {
				"!type": "fn(objects: [], recursive: bool) -> []",
				"!doc": "Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by [page:.intersectObject]."
			}
		},
		"!doc": "This class makes raycasting easier. Raycasting is used for picking and more.",
		"!type": "fn(origin: +Vector3, direction: +Vector3, near: number, far: number)"
	},
	"Lut": {
		"!url": "http://threejs.org/docs/#api/examples/Lut",
		"prototype": {
			"minV": {
				"!type": "number",
				"!doc": "The minimum value to be represented with the lookup table. Default is 0."
			},
			"maxV": {
				"!type": "number",
				"!doc": "The maximum value to be represented with the lookup table. Default is 1."
			},
			"copy": {
				"!type": "fn(lut: +Lut)",
				"!doc": "Copies given lut."
			},
			"setminV": {
				"!type": "fn(minV: number) -> +Lut",
				"!doc": "Sets this Lut with the minimum value to be represented."
			},
			"setmaxV": {
				"!type": "fn(maxV: number) -> +Lut",
				"!doc": "Sets this Lut with the maximum value to be represented."
			},
			"changeNumberOfColors": {
				"!type": "fn(numberOfColors: number) -> +Lut",
				"!doc": "Sets this Lut with the number of colors to be used."
			},
			"changeColorMap": {
				"!type": "fn(colorMap: number) -> +Lut",
				"!doc": "Sets this Lut with the colormap to be used."
			},
			"addColorMap": {
				"!type": "fn(colorMapName, arrayOfColors) -> +Lut",
				"!doc": "Insert a new color map into the set of available color maps."
			},
			"getColor": {
				"!type": "fn(value) -> +Lut",
				"!doc": "Returns a Three.Color."
			}
		},
		"!doc": "Represents a lookup table for colormaps. It is used to determine the color values from a range of data values.",
		"!type": "fn(colormap, numberOfColors)"
	},
	"CombinedCamera": {
		"!url": "http://threejs.org/docs/#api/examples/cameras/CombinedCamera",
		"prototype": {
			"!proto": "Camera.prototype",
			"fov": {
				"!type": "number",
				"!doc": "Gets or sets the camera frustum vertical field of view in perspective view."
			},
			"left": {
				"!type": "number",
				"!doc": "Gets or sets the camera frustum left plane in orthographic view."
			},
			"right": {
				"!type": "number",
				"!doc": "Gets or sets the camera frustum right plane in orthographic view."
			},
			"top": {
				"!type": "number",
				"!doc": "Gets or sets the camera frustum top plane in orthographic view."
			},
			"bottom": {
				"!type": "number",
				"!doc": "Gets or sets the camera frustum bottom plane in orthographic view."
			},
			"zoom": {
				"!type": "number",
				"!doc": "Gets or sets the zoom factor of the camera."
			},
			"near": {
				"!type": "number",
				"!doc": "Gets camera frustum near plane."
			},
			"far": {
				"!type": "number",
				"!doc": "Gets camera frustum far plane."
			},
			"cameraO": {
				"!type": "+OrthographicCamera",
				"!doc": "Gets or sets the internal OrthographicCamera used as camera."
			},
			"cameraP": {
				"!type": "+PerspectiveCamera",
				"!doc": "Gets or sets the internal PerspectiveCamera used as camera."
			},
			"inOrthographicMode": {
				"!type": "boolean",
				"!doc": "Gets whether the combinedCamera is in Orthographic Mode."
			},
			"inPerspectiveMode": {
				"!type": "boolean",
				"!doc": "Gets whether the combinedCamera is in Perspective Mode."
			},
			"setFov": {
				"!type": "fn(fov: number)",
				"!doc": "sets the camera frustum vertical field of view in perspective view."
			},
			"setZoom": {
				"!type": "fn(zoom: number)",
				"!doc": "Sets the zoomfactor."
			},
			"setLens": {
				"!type": "fn(focalLength: number, frameHeight: number)",
				"!doc": "Sets the fov based on lens data."
			},
			"toFrontView": {
				"!type": "fn()",
				"!doc": "Sets the camera to view the front of the target."
			},
			"toBackView": {
				"!type": "fn()",
				"!doc": "Sets the camera to view the back of the target."
			},
			"toLeftView": {
				"!type": "fn()",
				"!doc": "Sets the camera to view the left of the target."
			},
			"toRightView": {
				"!type": "fn()",
				"!doc": "Sets the camera to view the right of the target."
			},
			"toTopView": {
				"!type": "fn()",
				"!doc": "Sets the camera to view the top."
			},
			"toBottomView": {
				"!type": "fn()",
				"!doc": "Sets the camera to view the bottom."
			},
			"setSize": {
				"!type": "fn(width: number, height: number)",
				"!doc": "Sets the size of the orthographic view."
			},
			"toOrthographic": {
				"!type": "fn()",
				"!doc": "Change the camera to orthographic view."
			},
			"toPerspective": {
				"!type": "fn()",
				"!doc": "Change the camera to Perspective view."
			},
			"updateProjectionMatrix": {
				"!type": "fn()",
				"!doc": "Updates the ProjectionMatrix."
			}
		},
		"!doc": "A general purpose camera, for setting FOV, Lens Focal Length,\n \t\tand switching between perspective and orthographic views easily.\n \t\tUse this only if you do not wish to manage\n \t\tboth an Orthographic and Perspective Camera",
		"!type": "fn(width: number, height: number, fov: number, near: number, far: number, orthoNear: number, orthoFar: number)"
	},
	"FontUtils": {
		"!url": "http://threejs.org/docs/#api/extras/FontUtils",
		"prototype": {
			"divisions": {
				"!type": "number",
				"!doc": "The amount of segments in a curve. Default is 10."
			},
			"style": {
				"!type": "string",
				"!doc": "The style of the used font. Default is \"normal\"."
			},
			"weight": {
				"!type": "string",
				"!doc": "The weight of the used font. Default is \"normal\"."
			},
			"face": {
				"!type": "string",
				"!doc": "The name of the font. Default is \"helvetiker\"."
			},
			"faces": {
				"!type": "object",
				"!doc": "All Fonts which are already loaded in."
			},
			"size": {
				"!type": "number",
				"!doc": "The size of the used Font. Default is 150."
			},
			"drawText": {
				"!type": "fn(text: string) -> object",
				"!doc": "Calculates the path and offset of the text in the used font. It returns an  object like { paths : fontPaths, offset : width }."
			},
			"Triangulate": {
				"!type": "fn(contour: [], indices: bool) -> []",
				"!doc": "Triangulates a contour into an array of faces."
			},
			"extractGlyphPoints": {
				"!type": "fn(c: string, face: string, scale: number, offset: number, path: +Path) -> object",
				"!doc": "This ectracts the glyphPoints of the character of the face and returns an object containing the path and the new offset."
			},
			"generateShapes": {
				"!type": "fn(text: string, parameters: object) -> []",
				"!doc": "Generates shapes from the text and return them as an Array of [page:Shape]."
			},
			"loadFace": {
				"!type": "fn(data: object) -> object",
				"!doc": "This loads and saves the data of the face and return the data. When you add the font Data as javascriptfile, then this automatically get called. So there is no need to do this yourself."
			},
			"getFace": {
				"!type": "fn() -> object",
				"!doc": "Returns the used font its data based on its style and weight."
			}
		},
		"!doc": "A class for text operations in three.js (See [page:TextGeometry])"
	},
	"GeometryUtils": {
		"!url": "http://threejs.org/docs/#api/extras/GeometryUtils",
		"prototype": {},
		"!doc": "Contains handy functions geometry manipulations."
	},
	"ImageUtils": {
		"!url": "http://threejs.org/docs/#api/extras/ImageUtils",
		"prototype": {
			"crossOrigin": {
				"!type": "string",
				"!doc": "The crossOrigin string to implement CORS for loading the image from a different domain that allows CORS."
			},
			"generateDataTexture": {
				"!type": "fn(width: number, height: number, color: number) -> +DataTexture",
				"!doc": "Generates a texture of a single color. It is a DataTexture with format, RGBFormat."
			},
			"parseDDS": {
				"!type": "fn(buffer: string, loadMipmaps: boolean) -> +CompressedTexture",
				"!doc": "Parses a DDS Image from the string into a CompressedTexture."
			},
			"loadCompressedTexture": {
				"!type": "fn(url: todo, mapping: todo, onLoad: todo, onError: todo) -> todo",
				"!doc": "todo"
			},
			"loadTexture": {
				"!type": "fn(url: string, mapping: UVMapping, onLoad: function, onError: function) -> todo",
				"!doc": "todo"
			},
			"getNormalMap": {
				"!type": "fn(image: todo, depth: todo) -> todo",
				"!doc": "todo"
			},
			"loadCompressedTextureCube": {
				"!type": "fn(array: todo, mapping: todo, onLoad: todo, onError: todo) -> todo",
				"!doc": "todo"
			},
			"loadTextureCube": {
				"!type": "fn(array: todo, mapping: todo, onLoad: todo, onError: todo) -> todo",
				"!doc": "todo"
			}
		},
		"!doc": "A Helper class to ease the loading of images of different types."
	},
	"SceneUtils": {
		"!url": "http://threejs.org/docs/#api/extras/SceneUtils",
		"prototype": {
			"createMultiMaterialObject": {
				"!type": "fn(geometry: +Geometry, materials: []) -> +Object3D",
				"!doc": "Creates an new Object3D an new mesh for each material defined in materials. Beware that this is not the same as MultiMaterial which defines multiple material for 1 mesh.<br>\n\t\tThis is mostly useful for object that need a material and a wireframe implementation."
			},
			"attach": {
				"!type": "fn(child: +Object3D, scene: +Object3D, parent: +Object3D)",
				"!doc": "Attaches the object to the parent without the moving the object in the worldspace."
			},
			"detach": {
				"!type": "fn(child: +Object3D, parent: +Object3D, scene: +Object3D)",
				"!doc": "Detaches the object from the parent and adds it back to the scene without moving in worldspace."
			}
		},
		"!doc": "A class containing useful utility functions for scene manipulation."
	},
	"Curve": {
		"!url": "http://threejs.org/docs/#api/extras/core/Curve",
		"prototype": {
			"getPoint": {
				"!type": "fn(t) -> Vector",
				"!doc": "Returns a vector for point t of the curve where t is between 0 and 1"
			},
			"getPointAt": {
				"!type": "fn(u) -> Vector",
				"!doc": "Returns a vector for point at relative position in curve according to arc length"
			},
			"getPoints": {
				"!type": "fn(divisions) -> []",
				"!doc": "Get sequence of points using getPoint( t )"
			},
			"getSpacedPoints": {
				"!type": "fn(divisions) -> []",
				"!doc": "Get sequence of equi-spaced points using getPointAt( u )"
			},
			"getLength": {
				"!type": "fn() -> number",
				"!doc": "Get total curve arc length"
			},
			"getLengths": {
				"!type": "fn(divisions) -> []",
				"!doc": "Get list of cumulative segment lengths"
			},
			"updateArcLengths": {
				"!type": "fn()",
				"!doc": "Update the cumlative segment distance cache"
			},
			"getUtoTmapping": {
				"!type": "fn(u, distance) -> number",
				"!doc": "Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant"
			},
			"getTangent": {
				"!type": "fn(t) -> Vector",
				"!doc": "Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation"
			},
			"getTangentAt": {
				"!type": "fn(u) -> Vector",
				"!doc": "Returns tangent at equidistant point u on the curve"
			}
		},
		"!doc": "An extensible curve object which contains methods for interpolation.",
		"!type": "fn()"
	},
	"CurvePath": {
		"!url": "http://threejs.org/docs/#api/extras/core/CurvePath",
		"prototype": {
			"!proto": "Curve.prototype",
			"curves": {
				"!type": "array",
				"!doc": "todo"
			},
			"bends": {
				"!type": "array",
				"!doc": "todo"
			},
			"autoClose": {
				"!type": "boolean",
				"!doc": "todo"
			},
			"getWrapPoints": {
				"!type": "fn(oldPts: todo, path: todo) -> todo",
				"!doc": "todo"
			},
			"createPointsGeometry": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "todo"
			},
			"addWrapPath": {
				"!type": "fn(bendpath: todo) -> todo",
				"!doc": "todo"
			},
			"createGeometry": {
				"!type": "fn(points: todo) -> todo",
				"!doc": "todo"
			},
			"add": {
				"!type": "fn(curve: todo) -> todo",
				"!doc": "todo"
			},
			"getTransformedSpacedPoints": {
				"!type": "fn(segments: todo, bends: todo) -> todo",
				"!doc": "todo"
			},
			"createSpacedPointsGeometry": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "todo"
			},
			"closePath": {
				"!type": "fn() -> todo",
				"!doc": "todo"
			},
			"getBoundingBox": {
				"!type": "fn() -> todo",
				"!doc": "todo"
			},
			"getCurveLengths": {
				"!type": "fn() -> todo",
				"!doc": "todo"
			},
			"getTransformedPoints": {
				"!type": "fn(segments: todo, bends: todo) -> todo",
				"!doc": "todo"
			},
			"checkConnection": {
				"!type": "fn() -> todo",
				"!doc": "todo"
			}
		},
		"!doc": "todo",
		"!type": "fn()"
	},
	"Path": {
		"!url": "http://threejs.org/docs/#api/extras/core/Path",
		"prototype": {
			"!proto": "CurvePath.prototype",
			"actions": {
				"!type": "array",
				"!doc": "The possible actions that define the path."
			},
			"fromPoints": {
				"!type": "fn(vectors) -> todo",
				"!doc": "Adds to the Path from the points. The first vector defines the offset. After that the lines get defined."
			},
			"moveTo": {
				"!type": "fn(x, y) -> todo",
				"!doc": "This moves the offset to x and y"
			},
			"lineTo": {
				"!type": "fn(x, y) -> todo",
				"!doc": "This creates a line from the offset to X and Y and updates the offset to X and Y."
			},
			"quadraticCurveTo": {
				"!type": "fn(aCPx, aCPy, aX, aY) -> todo",
				"!doc": "This creates a quadratic curve from the offset to aX and aY with aCPx and aCPy as control point and updates the offset to aX and aY."
			},
			"bezierCurveTo": {
				"!type": "fn(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) -> todo",
				"!doc": "This creates a bezier curve from the offset to aX and aY with aCP1x, aCP1y and aCP1x, aCP1y  as control points and updates the offset to aX and aY."
			},
			"arc": {
				"!type": "fn(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
				"!doc": "todo"
			},
			"absarc": {
				"!type": "fn(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
				"!doc": "todo"
			},
			"ellipse": {
				"!type": "fn(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
				"!doc": "todo"
			},
			"absellipse": {
				"!type": "fn(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) -> todo",
				"!doc": "todo"
			},
			"toShapes": {
				"!type": "fn() -> todo",
				"!doc": "todo"
			}
		},
		"!doc": "A 2d path representation, comprising of points, lines, and cubes,  similar to the html5 2d canvas api. It extends CurvePath.",
		"!type": "fn(points: todo)"
	},
	"Shape": {
		"!url": "http://threejs.org/docs/#api/extras/core/Shape",
		"prototype": {
			"!proto": "Path.prototype",
			"holes": {
				"!type": "array",
				"!doc": "todo"
			},
			"makeGeometry": {
				"!type": "fn(options: todo) -> todo",
				"!doc": "Convenience method to return ShapeGeometry"
			},
			"extractAllPoints": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "Get points of shape and holes (keypoints based on segments parameter)"
			},
			"extrude": {
				"!type": "fn(options: todo) -> todo",
				"!doc": "Convenience method to return ExtrudeGeometry"
			},
			"extractPoints": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "todo"
			},
			"extractAllSpacedPoints": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "todo"
			},
			"getPointsHoles": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "Get points of holes"
			},
			"getSpacedPointsHoles": {
				"!type": "fn(divisions: todo) -> todo",
				"!doc": "Get points of holes (spaced by regular distance)"
			}
		},
		"!doc": "Defines a 2d shape plane using paths.",
		"!type": "fn()"
	},
	"ArcCurve": {
		"!url": "http://threejs.org/docs/#api/extras/curves/ArcCurve",
		"prototype": {
			"!proto": "EllipseCurve.prototype"
		},
		"!doc": "Alias for [page:EllipseCurve]"
	},
	"CubicBezierCurve": {
		"!url": "http://threejs.org/docs/#api/extras/curves/CubicBezierCurve",
		"prototype": {
			"!proto": "Curve.prototype",
			"v0": "+Vector2",
			"v1": "+Vector2",
			"v2": "+Vector2",
			"v3": "+Vector2"
		},
		"!doc": "Create a smooth 2d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg\" target=\"_blank\">cubic bezier curve</a>."
	},
	"CubicBezierCurve3": {
		"!url": "http://threejs.org/docs/#api/extras/curves/CubicBezierCurve3",
		"prototype": {
			"!proto": "Curve.prototype",
			"v0": "+Vector3",
			"v1": "+Vector3",
			"v2": "+Vector3",
			"v3": "+Vector3"
		},
		"!doc": "Create a smooth 3d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:Bezier_curve.svg\" target=\"_blank\">cubic bezier curve</a>.",
		"!type": "fn(v0: +Vector3, v1: +Vector3, v2: +Vector3, v3: +Vector3)"
	},
	"EllipseCurve": {
		"!url": "http://threejs.org/docs/#api/extras/curves/EllipseCurve",
		"prototype": {
			"!proto": "Curve.prototype",
			"aX": "number",
			"aY": "number",
			"xRadius": "Radians",
			"yRadius": "Radians",
			"aStartAngle": "number",
			"aEndAngle": "number",
			"aClockwise": "bool"
		},
		"!doc": "Creates a 2d curve in the shape of an ellipse.",
		"!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: Radians, aEndAngle: Radians, aClockwise: bool)"
	},
	"LineCurve": {
		"!url": "http://threejs.org/docs/#api/extras/curves/LineCurve",
		"prototype": {
			"!proto": "Curve.prototype",
			"v1": "+Vector2",
			"v2": "+Vector2"
		},
		"!doc": "A curve representing a 2d line segment",
		"!type": "fn(v1: +Vector2, v2: +Vector2)"
	},
	"LineCurve3": {
		"!url": "http://threejs.org/docs/#api/extras/curves/LineCurve3",
		"prototype": {
			"!proto": "Curve.prototype",
			"v1": "+Vector3",
			"v2": "+Vector3"
		},
		"!doc": "A curve representing a 3d line segment",
		"!type": "fn(v1: +Vector3, v2: +Vector3)"
	},
	"QuadraticBezierCurve": {
		"!url": "http://threejs.org/docs/#api/extras/curves/QuadraticBezierCurve",
		"prototype": {
			"!proto": "Curve.prototype",
			"v0": "+Vector2",
			"v1": "+Vector2",
			"v2": "+Vector2"
		},
		"!doc": "Create a smooth 2d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif\" target=\"_blank\">quadratic bezier curve</a>.",
		"!type": "fn(v0: +Vector2, v1: +Vector2, v2: +Vector2)"
	},
	"QuadraticBezierCurve3": {
		"!url": "http://threejs.org/docs/#api/extras/curves/QuadraticBezierCurve3",
		"prototype": {
			"!proto": "Curve.prototype",
			"v0": "+Vector3",
			"v1": "+Vector3",
			"v2": "+Vector3"
		},
		"!doc": "Create a smooth 3d <a href=\"http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif\" target=\"_blank\">quadratic bezier curve</a>.",
		"!type": "fn(v0: +Vector3, v1: +Vector3, v2: +Vector3)"
	},
	"SplineCurve": {
		"!url": "http://threejs.org/docs/#api/extras/curves/SplineCurve",
		"prototype": {
			"!proto": "Curve.prototype",
			"points": "[]"
		},
		"!doc": "Create a smooth 2d spline curve from a series of points",
		"!type": "fn(points: [])"
	},
	"BoxGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/BoxGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "BoxGeometry is the quadrilateral primitive geometry class. It is typically used for creating a cube or irregular quadrilateral of the dimensions provided with the 'width', 'height', and 'depth' constructor arguments.",
		"!type": "fn(width: number, height: number, depth: number, widthSegments: number, heightSegments: number, depthSegments: number)"
	},
	"CircleGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/CircleGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "CircleGeometry is a simple shape of Euclidean geometry.  It is contructed from a number of triangular segments that are oriented around a central point and extend as far out as a given radius.  It is built counter-clockwise from a start angle and a given central angle.  It can also be used to create regular polygons, where the number of segments determines the number of sides.",
		"!type": "fn(radius: number, segments: number, thetaStart: number, thetaLength: number)"
	},
	"CubeGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/CubeGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "Renamed CubeGeometry to BoxGeometry. see [page:BoxGeometry]."
	},
	"CylinderGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/CylinderGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "A class for generating cylinder geometries",
		"!type": "fn(radiusTop: number, radiusBottom: number, height: number, radiusSegments: number, heightSegments: number, openEnded: bool, thetaStart: number, thetaLength: number)"
	},
	"DodecahedronGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/DodecahedronGeometry",
		"prototype": {
			"!proto": "PolyhedronGeometry.prototype",
			"parameters": {
				"!type": "object",
				"!doc": "An object with all of the parameters that were used to generate the geometry."
			}
		},
		"!doc": "A class for generating a dodecahedron geometries.",
		"!type": "fn(radius: number, detail: number)"
	},
	"ExtrudeGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/ExtrudeGeometry",
		"prototype": {
			"!proto": "Geometry.prototype",
			"addShapeList": {
				"!type": "fn(shapes: [], options: object)",
				"!doc": "Adds the shapes to the list to extrude."
			},
			"addShape": {
				"!type": "fn(shape: +Shape, options: object)",
				"!doc": "Add the shape to the list to extrude."
			}
		},
		"!doc": "Creates extruded geometry from a path shape",
		"!type": "fn(shapes: [], options: object)"
	},
	"IcosahedronGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/IcosahedronGeometry",
		"prototype": {
			"!proto": "PolyhedronGeometry.prototype",
			"parameters": {
				"!type": "object",
				"!doc": "An object with all of the parameters that were used to generate the geometry."
			}
		},
		"!doc": "A class for generating an icosahedron geometry.",
		"!type": "fn(radius: number, detail: number)"
	},
	"LatheGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/LatheGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "Class for generating meshes with axial symmetry. Possible uses include donuts, pipes, vases etc. The lathe rotate around the Y axis.",
		"!type": "fn(points: [], segments: number, phiStart: number, phiLength: number)"
	},
	"OctahedronGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/OctahedronGeometry",
		"prototype": {
			"!proto": "PolyhedronGeometry.prototype",
			"parameters": {
				"!type": "object",
				"!doc": "An object with all of the parameters that were used to generate the geometry."
			}
		},
		"!doc": "A class for generating an octahedron geometry.",
		"!type": "fn(radius: number, detail: number)"
	},
	"ParametricGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/ParametricGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "Generate geometry representing a parametric surface.",
		"!type": "fn(func: function, slices: number, stacks: number)"
	},
	"PlaneGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/PlaneGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "A class for generating plane geometries",
		"!type": "fn(width: number, height: number, widthSegments: number, heightSegments: number)"
	},
	"PolyhedronGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/PolyhedronGeometry",
		"prototype": {
			"!proto": "Geometry.prototype",
			"parameters": {
				"!type": "object",
				"!doc": "An object with all of the parameters that were used to generate the geometry."
			}
		},
		"!doc": "A polyhedron is a solid in three dimensions with flat faces. This class will take an array of vertices,\n\t\t\tproject them onto a sphere, and then divide them up to the desired level of detail. This class is used\n\t\t\tby [page:DodecahedronGeometry], [page:IcosahedronGeometry], [page:OctahedronGeometry],\n\t\t\tand [page:TetrahedronGeometry] to generate their respective geometries.",
		"!type": "fn(vertices: [], faces: [], radius: number, detail: number)"
	},
	"RingGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/RingGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "A class for generating a two-dimensional ring geometry.",
		"!type": "fn(innerRadius: number, outerRadius: number, thetaSegments: number, phiSegments: number, thetaStart: number, thetaLength: number)"
	},
	"ShapeGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/ShapeGeometry",
		"prototype": {
			"!proto": "Geometry.prototype",
			"addShape": {
				"!type": "fn(shape: +Shape, options: object)",
				"!doc": "Adds a single shape to the geometry"
			}
		},
		"!doc": "Creates a one-sided polygonal geometry from one or more path shapes. Similar to [page:ExtrudeGeometry]",
		"!type": "fn(shapes: [], options: object)"
	},
	"SphereGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/SphereGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "A class for generating sphere geometries",
		"!type": "fn(radius: number, widthSegments: number, heightSegments: number, phiStart: number, phiLength: number, thetaStart: number, thetaLength: number)"
	},
	"TetrahedronGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/TetrahedronGeometry",
		"prototype": {
			"!proto": "PolyhedronGeometry.prototype",
			"parameters": {
				"!type": "object",
				"!doc": "An object with all of the parameters that were used to generate the geometry."
			}
		},
		"!doc": "A class for generating a tetrahedron geometries.",
		"!type": "fn(radius: number, detail: number)"
	},
	"TextGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/TextGeometry",
		"prototype": {
			"!proto": "ExtrudeGeometry.prototype"
		},
		"!doc": "This object creates an 3D object of text as a single object.",
		"!type": "fn(text: string, parameters: object)"
	},
	"TorusGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/TorusGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "A class for generating torus geometries",
		"!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, arc: number)"
	},
	"TorusKnotGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/TorusKnotGeometry",
		"prototype": {
			"!proto": "Geometry.prototype"
		},
		"!doc": "Creates a torus knot, the particular shape of which is defined by a pair of coprime integers, p and q.  If p and q are not coprime, the result will be a torus link.",
		"!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, heightScale: number)"
	},
	"TubeGeometry": {
		"!url": "http://threejs.org/docs/#api/geometries/TubeGeometry",
		"prototype": {
			"!proto": "Geometry.prototype",
			"parameters": {
				"!type": "object",
				"!doc": "An object with all of the parameters that were used to generate the geometry."
			},
			"tangents": {
				"!type": "[]",
				"!doc": "An array of [page:Vector3] tangents"
			},
			"normals": {
				"!type": "[]",
				"!doc": "An array of [page:Vector3] normals"
			},
			"binormals": {
				"!type": "[]",
				"!doc": "An array of [page:Vector3] binormals"
			}
		},
		"!doc": "Creates a tube that extrudes along a 3d curve",
		"!type": "fn(path: +Curve, segments: number, radius: number, radiusSegments: number, closed: bool)"
	},
	"ArrowHelper": {
		"!url": "http://threejs.org/docs/#api/extras/helpers/ArrowHelper",
		"prototype": {
			"!proto": "Object3D.prototype",
			"line": {
				"!type": "+Line",
				"!doc": "Contains the line part of the arrowHelper."
			},
			"cone": {
				"!type": "+Mesh",
				"!doc": "Contains the cone part of the arrowHelper."
			},
			"setColor": {
				"!type": "fn(hex: number)",
				"!doc": "Sets the color of the arrowHelper."
			},
			"setLength": {
				"!type": "fn(length: number, headLength: number, headWidth: number)",
				"!doc": "Sets the length of the arrowhelper."
			},
			"setDirection": {
				"!type": "fn(dir: +Vector3)",
				"!doc": "Sets the direction of the arrowhelper."
			}
		},
		"!doc": "An 3D arrow Object.",
		"!type": "fn(dir: +Vector3, origin: +Vector3, length: number, hex: number, headLength: number, headWidth: number)"
	},
	"AxisHelper": {
		"!url": "http://threejs.org/docs/#api/extras/helpers/AxisHelper",
		"prototype": {
			"!proto": "Line.prototype"
		},
		"!doc": "An axis object to visualize the the 3 axes in a simple way. <br>\n\t\t\tThe X axis is red. The Y axis is green. The Z axis is blue.",
		"!type": "fn(size: number)"
	},
	"BoundingBoxHelper": {
		"!url": "http://threejs.org/docs/#api/extras/helpers/BoundingBoxHelper",
		"prototype": {
			"!proto": "Mesh.prototype",
			"object": {
				"!type": "+Object3D",
				"!doc": "Contains the object3D to show the world-axis-aligned boundingbox."
			},
			"box": {
				"!type": "+Box3",
				"!doc": "Contains the bounding box of the object."
			},
			"update": {
				"!type": "fn()",
				"!doc": "Updates the BoundingBoxHelper based on the object property."
			}
		},
		"!doc": "A helper object to show the world-axis-aligned bounding box for an object.",
		"!type": "fn(object: +Object3D, hex: number)"
	},
	"BoxHelper": {
		"!url": "http://threejs.org/docs/#api/extras/helpers/BoxHelper",
		"prototype": {
			"!proto": "Line.prototype",
			"update": {
				"!type": "fn(object: +Object3D)",
				"!doc": "Updates the helper's geometry to match the dimensions of the [page:Geometry.boundingBox bounding box] of the passed object's geometry.\n\n\t\t<h2>Source</h2>\n\n\t\t[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]"
			}
		},
		"!doc": "Helper object to show a wireframe box (with no face diagonals) around an object",
		"!type": "fn(object: +Object3D)"
	},
	"CameraHelper": {
		"!url": "http://threejs.org/docs/#api/extras/helpers/CameraHelper",
		"prototype": {
			"!proto": "Line.prototype",
			"pointMap": {
				"!type": "object",
				"!doc": "This contains the points to viualize the cameraHelper"
			},
			"camera": {
				"!type": "+Camera",
				"!doc": "The camera to visualize."
			},
			"update": {
				"!type": "fn()",
				"!doc": "Updates the helper based on the projectionMatrix of the camera."
			}
		},
		"!doc": "The camera Helper is an Object3D which helps visualizing what a camera contains in its frustum.<br>\n\t\tIt visualizes the frustum with an line Geometry.",
		"!type": "fn(camera: +Camera)"
	},
	"DirectionalLightHelper": {
		"!url": "http://threejs.org/docs/#api/extras/helpers/DirectionalLightHelper",
		"prototype": {
			"!proto": "Object3D.prototype",
			"li